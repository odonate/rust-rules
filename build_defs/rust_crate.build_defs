def _rustc_crate_cmds(
        crate_name:str,
        version:str,
        edition:str="2018",
        src_root:str=None,
        err_format:str='json',
        crate_type:str|list='lib',
        emit:str|list=['dep-info', 'metadata', 'link'],
        codegen:dict={'embed-bitcode': 'no'},
        features:list=None,
        out_dir='target/debug/deps',
        search_path:str|list|dict=None,
        cap_lints='allow',
        externs:list=None,
        build_out:str=None,
        warns:list=None,
        allows:list=None,
        compile_env:dict=None,
):
    """Returns the commands to pass to rustc, and tools to use for it.
    
    We replicate the way Cargo invokes the rustc compiler as close as possible.

    Args:
        crate_name (str): Name of the crate being built. Required.
        version (str): Version of the crate. Required.
        edition (str): Edition of rust to use for this crate specified in the crate's Cargo.toml.
                  Rust has different editions (2015, 2018, 2021) that represent sets of language 
                  features. Ensures crate is compiled with appropriate features.
        src_root (str): The path to script being compiled. Specifies a path to append to the $SRCS of
                  the compilation rule using these commands.
        err_format (str): Controls the format of error messages. Messages are printed to stderr. The
                  valid options are: human, json, short.
        crate_type (str|list): Instructs rustc on which crate types to build. The valid crate types
                  are: lib (defaults to rlib), rlib, staticlib, dylib, cdylib, bin, proc-macro.
        emit (str|list): Controls the type of output files generated by the compiler. The valid emit
                  kinds are: asm, dep-info, link, llvm-bc, llvm-ir, metadata, mir, obj.
        codegen (dict): All of these options are passed to rustc via -C flags, short for codegen. To
                  see a version of this list for your compiler run `plz rustc -- -C help`.
                  Rust Rules fingerprints filenames with the version via the metadata and extra-filename flags.
        features (list): Configures the compilation environment. These flags turn on or off various
                  `#[cfg]` settings for conditional compilation. For example, `--cfg feature="serde"`
                   turns on `#[cfg(feature = "serde")]`.
        out_dir (str): The outputted crate will be written to this directory.
        search_path (str|list|dict): Options are passed to rust via -L flags. Adds path to search 
                  for crates and libraries. If a dict, it specifies the search_path in the form 
                  `-L KIND=PATH` where KIND may be one of: dependency, crate, native, framework, all.
        cap_lints (string): Sets the lint cap level, the maximum level for all lints. This feature
                  is used heavily by Cargo; it will pass `--cap-lints allow` when compiling your 
                  dependencies, so that if they have any warnings, they do not pollute the output.
        externs (list): Specifies where external libraries are located. Allows you to pass the name
                  and location for an external crate of a direct dependency. The given crate name is
                  added to the extern prelude, similar to specifying `extern crate` within the root
                  module.
        build_out (string): The output of any build scripts that were run.
        warns (list): Sets which lints should be set to warn level. Note: The order of these lint
                  level arguments is taken into account, see 
                  `https://doc.rust-lang.org/rustc/lints/levels.html#via-compiler-flag` for more
                  information.
        allows (list): Sets which lints should be set to allow level. Note: The order of these lint
                  level arguments is taken into account, see 
                  `https://doc.rust-lang.org/rustc/lints/levels.html#via-compiler-flag` for more
                  information.
        compile_env (dict): Environment variables to export at compile time.
    """
    export_envs = [f'export {k}={v} && ' for k,v in sorted(compile_env.items())] if compile_env else []
    cmd = export_envs + ['$TOOLS_RUSTC']
    if crate_name:
        cmd.append('--crate-name ' + crate_name)
    if edition:
        cmd.append(f'--edition={edition}')
    if src_root:
        cmd.append(f'$SRCS/{src_root}')
    else:
        cmd.append('$SRCS')
    if err_format:
        cmd.append(f'--error-format={err_format}')
        if err_format == 'json':
            cmd.append('--json=diagnostic-rendered-ansi,artifacts,future-incompat')
    cmd.append('--diagnostic-width=150')
    if crate_type is None:
        pass
    elif isinstance(crate_type, str):
        cmd.append(f'--crate-type {crate_type}')
    elif isinstance(crate_type, list):
        crate_types = ','.join(crate_type)
        cmd.append(f'--crate-type {crate_types}')
    if emit is None:
        pass
    elif isinstance(emit, str):
        cmd.append(f'--emit={emit}')
    elif isinstance(emit, list):
        emits = ','.join(emit)
        cmd.append(f'--emit={emits}')
    codegen['metadata'] = version
    codegen['extra-filename'] = f'-{version}'
    if codegen:
        cmd.extend([f'-C {k}={v}' for k,v in sorted(codegen.items())])
    if features:
        cmd.extend([f'--cfg feature=\\"{feature}\\"' for feature in features])
    if warns:
        cmd.extend([f'--warn="{warn}"' for warn in warns])
    if allows:
        cmd.extend([f'--allow="{allow}"' for allow in allows])
    if out_dir:
        cmd.append(f'--out-dir {out_dir}')
    if search_path is None:
        pass
    elif isinstance(search_path, str):
        cmd.append(f'-L {search_path}')
    elif isinstance(search_path, list):
        cmd.extend([f'-L {path}' for path in search_path])
    elif isinstance(search_path, dict):
        cmd.extend([f'-L {k}={v}' for k,v in sorted(search_path.items())])
    cmd.append(f'-L $(cat $TOOLS_REPO_ROOT)/plz-out/gen/third_party/rust/{out_dir}')
    if externs:
        cmd.extend([extern for extern in externs])
    if cap_lints:
        cmd.append(f'--cap-lints {cap_lints}')
    if CONFIG.RUST.STDLIB:
        cmd.append('-L $TOOLS_STDLIB')
    if build_out:
        cmd.append(f'$(cat $(location {build_out}))') 
    cmd = ' '.join(cmd)
    return {
        'dbg': cmd + ' -g',
        'opt': cmd + ' -O',
    }, {
        'rustc': [CONFIG.RUST.RUSTC],
        'stdlib': [CONFIG.RUST.STDLIB],
        'repo_root': [CONFIG.RUST.REPO_ROOT],
    }


def rust_crate_download(
        name:str, crate:str, version:str,
):
    base = f'{crate}-{version}'
    # Download the crate.
    url = f'https://crates.io/api/v1/crates/{crate}/{version}/download'
    download = remote_file(
        name=f'{base}_download',
        url=url,
        out=f'{base}_download',
    )
    # Extract the tarball .cargo file.
    extraction = build_rule(
        name=base,
        tag="extraction",
        srcs=[download],
        outs = [f'{base}'],
        cmd = ' && '.join([
            'tar -xvzf $SRCS',
        ]),
        building_description = f'Extracting {base}...',
    )
    return filegroup(
        name = name,
        srcs = [extraction],
        deps = [extraction],
    )


def rust_crate(
        # Crate params.
        name:str, crate:str, version:str='', download:str='', edition:str='2015', src_root:str='src/lib.rs',
        features:list=None, deps:list|dict=None, crate_type:str='lib', out_dir:str='target/debug/deps',
        warns:list=None, allows:list=None, compile_env:dict=None,     
        # Build params.
        build_root:str=None, build_deps:list|dict=None, build_out_dir:str='target/debug/build',
        build_compile_env:dict={}, build_run_env:dict={},
        os:str=None,
        arch:str=None,
        visibility:list=["PUBLIC"],
):
    base = f'{crate}-{version}'
    if not download:
        download = rust_crate_download(
            name = f'{name}_dl',
            crate = crate,
            version = version
        )
    extra_deps = []
    extra_deps.append(download)
    
    # Run any required build scripts.
    if build_root:
        if not os:
            if CONFIG.OS == 'linux':
                os = 'unknown-linux-gnu'
            elif CONFIG.OS == 'darwin':
                os = 'apple-darwin'
            else:
                raise ParseError('Unknown OS %s, you must pass os explicitly to rust_crate' % CONFIG.OS)
        if not arch:
            if CONFIG.ARCH == 'amd64':
                arch = 'x86_64'
            elif CONFIG.ARCH == 'x86':
                arch = 'i686'
            else:
                raise ParseError('Unknown architecture %s, you must pass arch explicitly to rust_crate' % CONFIG.ARCH)
        host = f'{arch}-{os}'
        formatted_base = base.replace('-', '_').replace('.', '_')
        build_out_dir = f'{build_out_dir}/{formatted_base}'
        build_out = _collect_build_script_output(crate, version, download, build_root, build_deps, edition, build_out_dir, features, host, build_compile_env, build_run_env)
        extra_deps.append(build_out)
    else:
        build_out = None

    return _compile_rust_crate(
        name=name,
        download=download,
        crate=crate,
        version=version,
        edition=edition,
        src_root=src_root,
        features=features,
        deps=deps,
        crate_type=crate_type,
        out_dir=out_dir,
        build_out=build_out,
        extra_deps=extra_deps,
        warns=warns,
        allows=allows,
        compile_env=compile_env,
        visibility=visibility,
    )

def _compile_rust_crate(
        name:str, download:str, crate:str, version:str, edition:str, src_root:str, features:list,
        deps:list|dict, crate_type:str, out_dir:str, build_out:str, extra_deps:list, warns:list,
        allows:list, compile_env:dict, visibility:list,
):
    base = f'{crate}-{version}'
    crate_name = crate.replace('-', '_')
    cmd, tools = _rustc_crate_cmds(
        crate_name=crate_name,
        version=version,
        edition=edition,
        src_root=src_root,
        err_format='human',
        crate_type=crate_type,
        features=features,
        out_dir=out_dir,
        build_out=build_out,
        warns=warns,
        allows=allows,
        compile_env=compile_env,
    )
    if deps is None:
        pass
    elif isinstance(deps, list):
        crate_deps = deps
    elif isinstance(deps, dict):
        crate_deps = deps.values()
    else:
        fail(f'Unknown deps type {deps}')

    major, minor, _ = version.split('.')
    return build_rule(
        name = name,
        srcs = [download],
        outs = {
            'crate': [f'{out_dir}/lib{crate_name}-{version}.rlib' if crate_type in ['lib', 'rlib'] else None],
            'so': [f'{out_dir}/lib{crate_name}-{version}.so' if crate_type in ['proc-macro'] else None],
            'md': [f'{out_dir}/lib{crate_name}-{version}.rmeta' if crate_type in ['lib', 'rlib', 'proc-macro'] else None],
            'dep_info': [f'{out_dir}/{crate_name}-{major}.{minor}.d' if crate_type in ['lib', 'rlib', 'proc-macro'] else None],
            'bin': [f'{out_dir}/{crate_name}-{major}.{minor}' if crate_type in ['bin'] else None],
        },
        cmd = cmd,
        deps = crate_deps + extra_deps if deps else extra_deps,
        visibility = visibility,
        requires = ['rust'],
        labels=_construct_labels(crate_name, crate, version, crate_type, out_dir),
        tools = tools,
        binary = True if crate_type == 'bin' else False,
        pre_build=_collect_extern_paths(
            crate_name=crate_name,
            version=version,
            edition=edition,
            src_root=src_root,
            crate_type=crate_type,
            features=features,
            out_dir=out_dir,
            deps=deps,
            build_out=build_out,
            warns=warns,
            allows=allows,
            compile_env=compile_env,
        ) if deps else None,
        needs_transitive_deps = True,
        building_description = f'Compiling crate for {base}...',
    )
    
def _compile_build_script(
        crate:str, version:str, download:str, root:str, deps:list, edition:str, out_dir:str, features:list=None, compile_env:dict={},
):
    """Compiles the build script before execution"""
    crate_name = f'build_script_build'
    cmd, tools = _rustc_crate_cmds(
        crate_name=crate_name,
        version=version,
        edition=edition,
        src_root=root,
        err_format='human',
        crate_type='bin',
        emit=['dep-info', 'link'], # Omits metadata.
        features=features,
        out_dir=out_dir,
    )
    major, minor, _ = version.split('.')
    return build_rule(
        name = f'{crate}-{version}',
        tag = 'compile_build_script',
        srcs = [download],
        outs = {
            'build_bin': [f'{out_dir}/{crate_name}-{major}.{minor}'],
            'dep_info': [f'{out_dir}/{crate_name}-{major}.{minor}.d']
        },
        cmd = cmd,
        deps = deps,
        requires = ['rust'],
        tools = tools,
        env = compile_env,
        pre_build=_collect_extern_paths(
            crate_name=crate_name,
            version=version,
            edition=edition,
            src_root=root,
            crate_type='bin',
            out_dir=out_dir,
            deps=deps,
            features=features,
        ) if deps else None,
        building_description = f'Compiling build script for {crate}-{version}...',
    ), tools


def _run_build_script(
        crate:str, version:str, download:str, root:str, deps:list, edition:str, out_dir:str, features:list=None, host:str, compile_env:dict={}, run_env:dict={}
):
    """Run compiled build script before building package."""
    compilation, tools = _compile_build_script(crate, version, download, root, deps, edition, out_dir, features, compile_env)

    run_env['RUST_BACKTRACE'] = 'full'
    return build_rule(
        name=f'{crate}-{version}',
        tag = 'run_build_script',
        srcs = [compilation + '|build_bin'],
        cmd = ' && '.join([
            f'mkdir -p {out_dir}/out',
            # Export env vars used inside build script.
            f'export OUT_DIR={out_dir}/out',
            f'export RUSTC=$TOOLS_RUSTC',
            f'export HOST={host}',
            f'$SRCS > {out_dir}/out/output',
        ]),
        outs = { 'output': [f'{out_dir}/out'] },
        deps = [compilation],
        pass_env = ['TOOLS_RUSTC'],
        env = run_env,
        tools = tools,
        building_description = f'Running build script {crate}-{version}...',
    )


def _collect_build_script_output(
        crate:str, version:str, download:str, root:str, deps:list, edition:str, out_dir:str, features:list=None, host:str, compile_env:dict={}, run_env:dict={}
):
    build_exec = _run_build_script(crate, version, download, root, deps, edition, out_dir, features, host, compile_env, run_env)
    cmd = """
    output=""
    while IFS= read -r line; do
        if [[ $line == cargo:rustc-cfg=* ]]; then
            cfg="${line#cargo:rustc-cfg=}"
            output="$output --cfg $cfg"
        fi
    done < $SRCS/output"""
    return build_rule(
        name=f'{crate}-{version}',
        tag='collect_build_output',
        srcs=[build_exec + '|output'],
        cmd = ' && '.join([
            cmd,
            'echo $output > $OUTS',
        ]),
        outs = {
            'formatted_output': [f'{out_dir}/out/formatted_output'],
        },
        deps = [build_exec],
        building_description = f'Collecting build script outputs for {crate}-{version}...',
    )
        
    
def _construct_labels(crate_name:str, crate:str, version:str, crate_type:str, out_dir:str):
    """Returns the labels for a rust_crate based on the crate_type"""
    labels = []
    pkg = package_name()
    if crate_type in ['lib', 'rlib']:
        crate_label = f'rust_crate_path:{crate_name}:{pkg}/{out_dir}/lib{crate_name}-{version}.rlib'
        md_label = f'rust_md_path:{crate_name}:{pkg}/{out_dir}/lib{crate_name}-{version}.rmeta'
        labels.extend([crate_label, md_label])
    elif crate_type in ['proc-macro']:
        crate_label = f'rust_crate_path:{crate_name}:{pkg}/{out_dir}/lib{crate_name}-{version}.so'
        md_label = f'rust_md_path:{crate_name}:{pkg}/{out_dir}/lib{crate_name}-{version}.so'
        labels.extend([crate_label, md_label])
    elif crate_type in ['bin']:
        pass
    else:
        fail(f'Unsupported labels for crate type: {crate_type}')
    return labels
    
    
def _collect_extern_paths(
        crate_name:str,
        version:str,
        edition:str,
        src_root:str,
        crate_type:str,
        features:list,
        out_dir:str,
        deps:list|dict,
        build_out:str=None,
        warns:list=None,
        allows:list=None,
        compile_env:dict=None,
):
    """Returns the pre-build function to apply --extern to the rustc command"""
    def extern_flags(dep, labels, rename=None):
        """Filter out transitive deps. Rename if required"""
        externs = []
        for label in labels:
            flag = label.split(':')
            dep_crate = flag[0].replace('-', '_')
            dep_path = flag[1]
            if rename and (rename == dep_crate or dep[1:] == dep_crate):
                externs.append(f'--extern {rename}={dep_path}')
            elif not rename and dep[1:] == dep_crate:
                externs.append(f'--extern {dep_crate}={dep_path}')
        return externs
            
    def collect_extern_paths(name):
        externs = []
        label_format = 'rust_md_path:'
        if crate_type in ["bin", "proc-macro"]:
            label_format = 'rust_crate_path:'
            if crate_type == 'proc-macro':
                externs.append('--extern proc_macro')
        if isinstance(deps, dict):
            for rename, dep in deps.items():
                labels = get_labels(dep, label_format)
                externs += extern_flags(dep, labels, rename)
        elif isinstance(deps, list):
            for dep in deps:
                labels = get_labels(dep, label_format)
                externs += extern_flags(dep, labels)
        else:
            fail(f'Unknown dep type {deps}')
        if externs:
            cmds, _ = _rustc_crate_cmds(
                crate_name=crate_name,
                version=version,
                edition=edition,
                src_root=src_root,
                err_format='human',
                crate_type=crate_type,
                features=features,
                out_dir=out_dir,
                build_out=build_out,
                warns=warns,
                allows=allows,
                compile_env=compile_env,
                externs=externs,
            )
            for k, v in cmds.items():
                set_command(name, k, v)
    return collect_extern_paths
