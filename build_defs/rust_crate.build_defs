def _rustc_crate_cmds(
        name:str,
        crate_name:str,
        edition:str="2018",
        src_path:str=None,
        err_format:str='json',
        crate_type:str|list='lib',
        emit:str|list=['dep-info', 'metadata', 'link'],
        codegen:dict={'embed-bitcode': 'no'},
        features:list=None,
        out_dir='target/debug/deps',
        search_path:str|list|dict=None,
        deps:list=[],
        cap_lints='allow',
        externs:list=None,
        build_out:str=None,
):
    """Returns the commands to pass to rustc, and tools to use for it.
    
    We replicate the way Cargo invokes the rustc compiler as close as possible.

    Args:
        name (str): Name of the rule. Required.
        crate_name (str): Name of the crate being built. Required.
        edition (str): Edition of rust to use for this crate specified in the crate's Cargo.toml.
                  Rust has different editions (2015, 2018, 2021) that represent sets of language 
                  features. Ensures crate is compiled with appropriate features.
        src_path (str): The path to script being compiled. Specifies a path to append to the $SRCS of
                  the compilation rule using these commands.
        err_format (str): Controles the format of error messages. Messages are printed to stderr. The
                  valid options are: human, json, short.
        crate_type (str|list): Instructs rustc on which crate types to build. The valid crate types
                  are: lib (defaults to rlib), rlib, staticlib, dylib, cdylib, bin, proc-macro.
        emit (str|list): Controls the type of output files generated by the compiler. The valid emit
                  kinds are: asm, dep-info, link, llvm-bc, llvm-ir, metadaat, mir, obj.
        codegen (dict): All of these options are passed to rustc via -C flags, short for codegen. To
                  see a version of this list for your compiler run `plz rustc -- -C help`.
        features (list): Configures the compilation environment. These flags turn on or off various
                  `#[cfg]` settings for conditional compilation. For example, `--cfg feature="serde"`
                   turns on `#[cfg(feature = "serde")]`.
        out_dir (str): The outputted crate will be written to this directory.
        search_path (str|list|dict): Options are passed to rust via -L flags. Adds path to search 
                  for crates and libraries. If a dict, it specifies the search_path in the form 
                  `-L KIND=PATH` where KIND may be one of: dependency, crate, native, framework, all.
        externs (list): Specifies where external libraries are located. Allows you to pass the name
                  and location for an external crate of a direct dependency. The given crate name is
                  added to the extern prelude, similar to specifying `extern crate` within the root
                  module.
        cap_lints (string): Sets the lint cap level, the maximum level for all lints. This feature
                  is used heavily by Cargo; it will pass `--cap-lints allow` when compiling your 
                  dependencies, so that if they have any warnings, they do not pollute the output.
        build_out (string): The output of any build scripts that were run.
    """
    cmd = [f'$TOOLS_RUSTC']
    if crate_name:
        cmd.append('--crate-name ' + crate_name)
    if edition:
        cmd.append(f'--edition={edition}')
    if src_path:
        cmd.append(f'$SRCS/{src_path}')
    else:
        cmd.append('$SRCS')
    if err_format:
        cmd.append(f'--error-format={err_format}')
        if err_format == 'json':
            cmd.append('--json=diagnostic-rendered-ansi,artifacts,future-incompat')
    cmd.append('--diagnostic-width=150')
    if crate_type is None:
        pass
    elif isinstance(crate_type, str):
        cmd.append(f'--crate-type {crate_type}')
    elif isinstance(crate_type, list):
        crate_types = ','.join(crate_type)
        cmd.append(f'--crate-type {crate_types}')
    if emit is None:
        pass
    elif isinstance(emit, str):
        cmd.append(f'--emit={emit}')
    elif isinstance(emit, list):
        emits = ','.join(emit)
        cmd.append(f'--emit={emits}')
    if codegen:
        # TODO: -C metadata=xxx-hash-xxx
        # TODO: -C extra-filename=-xxx-hash-xxx 
        cmd.extend([f'-C {k}={v}' for k,v in sorted(codegen.items())])
    if features:
        cmd.extend([f'--cfg feature=\\"{feature}\\"' for feature in features])
    if out_dir:
        # TODO: use name-metadata instead of just name.
        cmd.append(f'--out-dir {out_dir}')
    if search_path is None:
        pass
    elif isinstance(search_path, str):
        cmd.append(f'-L {search_path}')
    elif isinstance(search_path, list):
        cmd.extend([f'-L {path}' for path in search_path])
    elif isinstance(search_path, dict):
        cmd.extend([f'-L {k}={v}' for k,v in sorted(search_path.items())])
    cmd.append(f'-L $(cat $TOOLS_TARGET)/plz-out/gen/third_party/rust/{out_dir}')
    if externs:
        cmd.extend([extern for extern in externs])
    if cap_lints:
        cmd.append(f'--cap-lints {cap_lints}')
    if CONFIG.RUST_STDLIB or CONFIG.RUST_TOOLCHAIN:
        cmd.append('-L $TOOLS_STDLIB')
    if build_out:
        cmd.append(f'$(cat $(location {build_out}))') 
    cmd = ' '.join(cmd)
    return {
        'dbg': cmd + ' -g',
        'opt': cmd + ' -O',
    }, {
        'rustc': [(CONFIG.RUST_TOOLCHAIN + '_rustc') if CONFIG.RUST_TOOLCHAIN else CONFIG.RUSTC_TOOL],
        'stdlib': [(CONFIG.RUST_TOOLCHAIN + '_stdlib') if CONFIG.RUST_TOOLCHAIN else CONFIG.RUST_STDLIB],
        'target': [(CONFIG.RUST_TOOLCHAIN + '_target') if CONFIG.RUST_TOOLCHAIN else CONFIG.RUST_TARGET_DIR],
    }


def rust_crate(
        name:str, crate:str, version:str, deps:list=None,
        build_script:str=None, features:list=None,
        binary:bool=False, visibility:list=["PUBLIC"],
        edition:str='2015',
        out_dir='target/debug/deps',
):
    base = f'{crate}-{version}'
    # Download the crate.
    url = f'https://crates.io/api/v1/crates/{crate}/{version}/download'
    download_rule = remote_file(
        name=f'{base}_download',
        url=url,
        out=f'{base}_download',
    )
    # Extract the tarball .cargo file.
    extract_rule = genrule(
        name=f'{base}_extraction',
        srcs=[download_rule],
        outs = {
            'src': [f'{base}/src'],
            'build_root': [f'{base}/{build_script}' if build_script else None],
        },
        cmd = " && ".join([
            'tar -xvzf $SRCS',
        ]),
        building_description = f'Extracting {base}...',
    )
    extra_deps = []
    src_rule = filegroup(
        name = base,
        tag = 'src',
        srcs = [extract_rule + '|src'],
        deps = [extract_rule],
    )
    extra_deps.append(src_rule)
    
    build_root = filegroup(
        name=base,
        tag='build_script',
        srcs = [extract_rule + '|build_root'],
        deps = [extract_rule],
    )
    
    # Run any required build scripts.
    if build_script:
        build_out = _collect_build_script_output(base, build_root, edition, out_dir)
        extra_deps.append(build_out)
    else:
        build_out = None

    return _compile_rust_crate(
        name=name,
        crate=crate,
        version=version,
        edition=edition,
        binary=binary,
        features=features,
        src_rule=src_rule,
        build_out=build_out,
        deps=deps,
        extra_deps=extra_deps,
        visibility=visibility,
        out_dir=out_dir,
    )

def _compile_rust_crate(
        name:str, crate:str, version:str, edition:str, binary:bool,
        features:list, src_rule:str, build_out:str, deps:list,
        extra_deps:list, visibility:list, out_dir:str,
):
    pkg = package_name()
    base = f'{crate}-{version}'
    crate_type = 'bin' if binary else 'lib'
    cmd, tools = _rustc_crate_cmds(
        name=base,
        crate_name=name,
        edition=edition,
        src_path='main.rs' if binary else 'lib.rs',
        err_format='human',
        crate_type=crate_type,
        out_dir=out_dir,
        features=features,
        build_out=build_out,
        deps=deps,
    )
    return build_rule(
        name = name,
        srcs = [src_rule],
        outs = {
            'crate': [f'{out_dir}/lib{name}.rlib'], # TODO: binaries.
            'md': [f'{out_dir}/lib{name}.rmeta'],
            'dep_info': [f'{out_dir}/{name}.d'],
        },
        cmd = cmd,
        deps = deps + extra_deps if deps else extra_deps,
        visibility = visibility,
        requires = ['rust'],
        labels=[
            f'rust_crate_path:{crate}:{pkg}/{out_dir}/lib{name}.rlib',
            f'rust_md_path:{crate}:{pkg}/{out_dir}/lib{name}.rmeta',
        ],
        tools = tools,
        pre_build=_collect_extern_paths(
            name=name,
            base=base,
            edition=edition,
            binary=binary,
            crate_type=crate_type,
            out_dir=out_dir,
            features=features,
            build_out=build_out,
            deps=deps,
        ) if deps else None,
    )
    
def _compile_build_script(
        name:str, root:str, edition:str, out_dir:str,
):
    """Compiles the build script before execution"""
    
    crate_name = f'{name}_build_script'.replace('-', '_').replace('.', '_')
    cmd, tools = _rustc_crate_cmds(
        name=name,
        crate_name=crate_name,
        edition=edition,
        err_format='human',
        crate_type='bin',
        emit=['dep-info', 'link'], # Omits metadata.
        out_dir=out_dir,
    )
    return build_rule(
        name = name,
        tag = 'compile_build_script',
        srcs = [root],
        outs = {
            'build_bin': [f'{out_dir}/{crate_name}'],
            'dep_info': [f'{out_dir}/{crate_name}.d']
        },
        cmd = cmd,
        requires = ['rust'],
        tools = tools,
        building_description = f'Compiling build script for {name}...',
    ), tools


def _run_build_script(
        name:str, root:str, edition:str, out_dir:str,
):
    """Run compiled build script before building package."""
    output_name = name.replace('-', '_').replace('.', '_')
    compilation, tools = _compile_build_script(name, root, edition, out_dir)
    return build_rule(
        name=name,
        tag = 'run_build_script',
        srcs = [compilation + '|build_bin'],
        cmd = ' && '.join([
            'export RUSTC=$TOOLS_RUSTC',
            f'$SRCS > $OUTS',
        ]),
        outs = { 'build_output': [f'{out_dir}/{output_name}_output'] },
        deps = [compilation],
        pass_env = ['TOOLS_RUSTC'],
        env = {
            'RUST_BACKTRACE': 'full',
        },
        tools = tools,
        building_description = f'Running build script {name}...',
    )


def _collect_build_script_output(
        name:str, root:str, edition:str, out_dir:str,
):
    build_exec = _run_build_script(name, root, edition, out_dir)
    output_name = name.replace('-', '_').replace('.', '_')
    cmd = """
    output=""
    while IFS= read -r line; do
        if [[ $line == cargo:rustc-cfg=* ]]; then
            cfg="${line#cargo:rustc-cfg=}"
            output="$output --cfg $cfg"
        fi
    done < $SRCS"""
    return build_rule(
        name=name,
        tag='collect_build_output',
        srcs=[build_exec + '|build_output'],
        cmd = ' && '.join([
            'echo $SRCS',
            cmd,
            'echo $output > $OUTS',
            'cat $OUTS', # TODO: rm debug
        ]),
        outs = { 'formatted_output': [f'{out_dir}/{output_name}_formatted_output'] },
        deps = [build_exec],
        building_description = f'Collecting build script outputs for {name}...',
    )
        
    
    
def _collect_extern_paths(
        name:str, base:str, edition:str, binary:bool,
        crate_type:str, out_dir:str, features:list,
        build_out:str, deps:list,
):
    """Returns the pre-build function to apply --extern to the rustc command"""
    def extern_flags(dep, labels):
        externs = []
        for label in labels: # TODO: filter out only the ones we need.
            flag = label.split(':')
            crate = flag[0].replace('-', '_')
            path = flag[1]
            if crate == dep[1:]:
                externs.append(f'--extern {crate}={path}')
        log.debug(f"Matched {externs} for {dep}")
        return externs
            
    def collect_extern_paths(name):
        externs = []
        for dep in deps:
            log.debug(f"Getting labels for {dep}")
            labels = get_labels(dep, 'rust_md_path:')
            log.debug(f"Found {labels} labels for {dep}")
            externs += extern_flags(dep, labels)
        if externs:
            cmds, _ = _rustc_crate_cmds(
                name=base,
                crate_name=name,
                edition=edition,
                src_path='main.rs' if binary else 'lib.rs',
                err_format='human',
                crate_type=crate_type,
                out_dir=out_dir,
                features=features,
                build_out=build_out,
                externs=externs,
                deps=deps,
            )
            for k, v in cmds.items():
                log.warning(k, v)
                set_command(name, k, v)
    return collect_extern_paths
