def _rustc_cmds(
        crate_name:str,
        edition:str="2021",
        err_format:str='human',
        crate_type:str='lib',
        emit:str|list=['dep-info', 'link'],
        codegen:dict={
            'embed-bitcode': 'no',
            'incremental': 'third_party/rust/target/debug/incremental',
        },
        features:list=None,
        out_dir='target/debug/deps',
        search_path:str|list|dict=None,
        deps:list=None,
        externs:list=None,
        build_out:str=None,
        test:bool=False,
        compile_env:dict=None,
):
    """Returns the commands to pass to rustc, and tools to use for it.

    We replicate the way Cargo invokes the rustc compiler as close as possible.

    Args:
        name (str): Name of the rule. Required.
        crate_name (str): Name of the crate being built. Required.
        edition (str): Edition of rust to use for this crate specified in the crate's Cargo.toml.
                  Rust has different editions (2015, 2018, 2021) that represent sets of language 
                  features. Ensures crate is compiled with appropriate features.
        err_format (str): Controls the format of error messages. Messages are printed to stderr. The
                  valid options are: human, json, short.
        crate_type (str|list): Instructs rustc on which crate types to build. The valid crate types
                  are: lib (defaults to rlib), rlib, staticlib, dylib, cdylib, bin, proc-macro.
        emit (str|list): Controls the type of output files generated by the compiler. The valid emit
                  kinds are: asm, dep-info, link, llvm-bc, llvm-ir, metadata, mir, obj.
        codegen (dict): All of these options are passed to rustc via -C flags, short for codegen. To
                  see a version of this list for your compiler run `plz rustc -- -C help`.
        features (list): Configures the compilation environment. These flags turn on or off various
                  `#[cfg]` settings for conditional compilation. For example, `--cfg feature="serde"`
                   turns on `#[cfg(feature = "serde")]`.
        out_dir (str): The outputted crate will be written to this directory.
        search_path (str|list|dict): Options are passed to rust via -L flags. Adds path to search 
                  for crates and libraries. If a dict, it specifies the search_path in the form 
                  `-L KIND=PATH` where KIND may be one of: dependency, crate, native, framework, all.
        externs (list): Specifies where external libraries are located. Allows you to pass the name
                  and location for an external crate of a direct dependency. The given crate name is
                  added to the extern prelude, similar to specifying `extern crate` within the root
                  module.
        build_out (string): The output of any build scripts that were run.
        test (bool): Build a test harness. When compiling this crate, `rustc` will ignore your `main`
                  function and instead produce a test harness.
        compile_env (dict): Environment variables to export at compile time.
    """
    export_envs = [f'export {k}={v} && ' for k,v in sorted(compile_env.items())] if compile_env else []
    cmd = export_envs + ['$TOOLS_RUSTC', '$SRCS']
    if crate_name:
        cmd.append('--crate-name=' + crate_name)
    if edition:
        cmd.append(f'--edition={edition}')
    if err_format:
        cmd.append(f'--error-format={err_format}')
        if err_format == 'json':
            cmd.append('--json=diagnostic-rendered-ansi,artifacts,future-incompat')
    cmd.append('--diagnostic-width=150')
    if crate_type is None:
        pass
    elif isinstance(crate_type, str):
        cmd.append(f'--crate-type {crate_type}')
    elif isinstance(crate_type, list):
        crate_types = ','.join(crate_type)
        cmd.append(f'--crate-type {crate_types}')
    if emit is None:
        pass
    elif isinstance(emit, str):
        cmd.append(f'--emit={emit}')
    elif isinstance(emit, list):
        emits = ','.join(emit)
        cmd.append(f'--emit={emits}')
    if codegen:
        # TODO: -C metadata=xxx-hash-xxx
        # TODO: -C extra-filename=-xxx-hash-xxx 
        cmd.extend([f'-C {k}={v}' for k,v in sorted(codegen.items())])
    if features:
        cmd.extend([f'--cfg feature=\\"{feature}\\"' for feature in features])
    if search_path is None:
        pass
    elif isinstance(search_path, str):
        cmd.append(f'-L {search_path}')
    elif isinstance(search_path, list):
        cmd.extend([f'-L {path}' for path in search_path])
    elif isinstance(search_path, dict):
        cmd.extend([f'-L {k}={v}' for k,v in sorted(search_path.items())])
    pkg = package_name()
    cmd.extend([
        f'-L {pkg}',
        f'-L third_party/rust/{out_dir}',
        f'-L $(git rev-parse --show-cdup)/plz-out/gen/third_party/rust/{out_dir}',
    ])
    if externs:
        cmd.extend([extern for extern in externs])
    # log.warning(CONFIG.RUST)
    # if CONFIG.RUST.STDLIB:
    cmd.append('-L $TOOLS_STDLIB')
    if build_out:
        cmd.append(f'$(cat $(location {build_out}))') 
    if test:
        cmd.append('--test')
    cmd = ' '.join(cmd)
    return {
        'dbg': cmd + ' -g',
        'opt': cmd + ' -O',
    }, {
        # TODO: why is CONFIG.RUST not set outside third_party?
        'rustc': ["//third_party/rust:toolchain_rustc"],
        'stdlib': ["//third_party/rust:toolchain_stdlib"],
    }


def rust_library(name:str, root:str, modules:list=None, deps:list=[], edition:str="2018", features:list=None, build_root:str=None, build_deps:list|dict=None, visibility:list=None):
    """Defines a build rule for a Rust library.

    Args:
        name (name): Name of the crate we're creating.
        root (str): Source file that the `rustc` compiler starts from and makes up the root module
                  of the crate. Typically, `src/lib.rs`.
        modules (list): Local modules that make up the crate.
        deps (lists): Third-party dependencies of this crate.
        edition (str): Edition of rust to use for this crate. Rust has different editions (2015,
                  2018, 2021) that represent sets of language features. Ensures crate is compiled
                  with appropriate features.
        visibility (list): Visibility declaration.
    """
    if modules:
        filegroup(
            name=f'{name}_mods',
            srcs=modules,
        )
        deps.append(f':{name}_mods')
    
    cmd, tools = _rustc_cmds(
        crate_name=name,
        edition=edition,
        deps=deps,
    )
    build_rule(
        name = name,
        srcs = [root],
        outs = [f'lib{name}.rlib'],
        cmd = cmd,
        deps = deps,
        visibility = visibility,
        requires = ['rust'],
        tools = tools,
        pre_build=_collect_extern_paths(
            crate_name=name,
            edition=edition,
            crate_type='lib',
            features=features,
            deps=deps,
        ) if deps else None,
    )


def rust_binary(name:str, main:str, deps:list=None, edition:str='2021', features:list=None, build_root:str=None, build_deps:list|dict=None, build_compile_env:dict=None, build_run_env:dict=None, visibility:list=None, _os:str=None, _arch:str=None):
    """Defines a build rule for a Rust standalone binary.

    Args:
        name (str): Name of the binary.
        main (str): Source file containing the `main()` function that the `rustc` compiler starts
                  from. Typically, `src/main.rs`.
        deps (list): Local modules and third-party dependencies of this crate.
        edition (str): Edition of rust to use for this crate. Rust has different editions (2015,
                  2018, 2021) that represent sets of language features. Ensures crate is compiled
                  with appropriate features.
        build_root (str): Source file containing a built script's `main()` functions. Optional.
        build_deps (list|dict): Local modules and third-party dependencies of the build script.
        visibility (list): Visibility declaration.
    """
    if build_root:        
        if not _os:
            if CONFIG.OS == 'linux':
                _os = 'unknown-linux-gnu'
            elif CONFIG.OS == 'darwin':
                _os = 'apple-darwin'
            else:
                raise ParseError('Unknown OS %s, you must pass os explicitly to rust_crate' % CONFIG.OS)
        if not _arch:
            if CONFIG.ARCH == 'amd64':
                _arch = 'x86_64'
            elif CONFIG.ARCH == 'x86':
                _arch = 'i686'
            else:
                raise ParseError('Unknown architecture %s, you must pass arch explicitly to rust_crate' % CONFIG.ARCH)
        build_out = _collect_build_script_output(name, build_root, build_deps, edition, features, build_compile_env, build_run_env)
    else:
        build_out = None
        
    cmd, tools = _rustc_cmds(
        crate_name=name,
        edition=edition,
        crate_type='bin',
        deps=deps,
    )
    build_rule(
        name = name,
        srcs = [main],
        binary = True,
        outs = [name],
        cmd = cmd,
        deps = deps,
        visibility = visibility,
        requires = ['rust'],
        tools = tools,
        pre_build=_collect_extern_paths(
            crate_name=name,
            edition=edition,
            crate_type='bin',
            features=features,
            deps=deps,
        ) if deps else None,
    )


def rust_test(name:str, root:str, modules:list=None, deps:list=[], edition:str="2018", features:list=None, visibility:list=None):
    """Defines a test rule for a Rust library.

    Note that while this correctly runs tests, the Rust test runner has no
    ability to output in any format we're familiar with. This is a known issue
    (see https://github.com/rust-lang/rfcs/issues/816) but it isn't resolved
    yet, so for now we do a straight pass-fail. Rumour has it that plz may gain
    some ability to parse Rust test logs soonish in which case we'd get slightly
    more detailed feedback here.

    Args:
        name (name): Name of the test harness we're creating.
        root (str): Source file that the `rustc` compiler starts from and makes up the test harness.
        modules (list): Local modules that make up the test harness.
        deps (lists): Third-party dependencies of the test harness.
        edition (str): Edition of rust to use for this test harness. Rust has different editions 
                  (2015, 2018, 2021) that represent sets of language features. Ensures crate is 
                  compiled with appropriate features.
        visibility (list): Visibility declaration.
    """
    if modules:
        filegroup(
            name=f'{name}_mods',
            srcs=modules,
        )
        deps.append(f':{name}_mods')
    
    cmd, tools = _rustc_cmds(
        crate_name=f'{name}_test',
        edition=edition,
        crate_type='bin',
        deps=deps,
        test=True,
    )
    build_rule(
        name = name,
        srcs = [root],
        binary = True,
        test = True,
        no_test_output = True, # see above
        outs = [f'{name}_test'],
        cmd = cmd,
        deps = deps,
        visibility = visibility,
        requires = ['rust'],
        tools = tools,
        pre_build=_collect_extern_paths(
            crate_name=name,
            edition=edition,
            crate_type='bin',
            features=features,
            deps=deps,
            test=True,
        ) if deps else None,
    )


def _compile_build_script(
        name:str, root:str, deps:list, edition:str, features:list=None, compile_env:dict={},
):
    """Compiles the build script before execution"""
    crate_name = f'build_script_build'
    cmd, tools = _rustc_cmds(
        crate_name=crate_name,
        edition=edition,
        err_format='human',
        crate_type='bin',
        emit=['dep-info', 'link'], # Omits metadata.
        features=features,
        deps=deps,
    )
    return build_rule(
        name = name,
        tag = 'compile_build_script',
        srcs = [root],
        outs = {
            'build_bin': [f'{crate_name}'],
            'dep_info': [f'{crate_name}.d']
        },
        cmd = cmd,
        deps = deps,
        requires = ['rust'],
        tools = tools,
        env = compile_env,
        pre_build=_collect_extern_paths(
            crate_name=crate_name,
            edition=edition,
            crate_type='bin',
            deps=deps,
            features=features,
        ) if deps else None,
        building_description = f'Compiling build script for {name}...',
    ), tools


def _run_build_script(name:str, root:str, deps:list, edition:str, features:list=None, compile_env:dict={}, run_env:dict={}):
    """Run compiled build script before building package."""
    compilation, tools = _compile_build_script(name, root, deps, edition, features, compile_env)
    run_env['RUST_BACKTRACE'] = 'full'
    return build_rule(
        name=name,
        tag='run_build_script',
        srcs = [compilation + '|build_bin'],
        cmd = ' && '.join([
            'mkdir -p out',
            '$SRCS -> out/output',
        ]),
        outs = { 'output': [ 'out' ] },
        deps = [ compilation ],
        pass_env = ['TOOLS_RUSTC'],
        env = run_env,
        tools = tools,
        building_description = f'Running build script {name}'
    )

        
def _collect_build_script_output(name:str, root:str, deps:list, edition:str, features:list=None, compile_env:dict={}, run_env:dict={}):
    build_exec = _run_build_script(name, root, deps, edition, features, compile_env, run_env)
    cmd = """
    output=""
    while IFS= read -r line; do
        if [[ $line == cargo:rustc-cfg=* ]]; then
            cfg="${line#cargo:rustc-cfg=}"
            output="$output --cfg $cfg"
        fi
    done < $SRCS/output"""
    return build_rule(
        name=name,
        tag='collect_build_output',
        srcs=[build_exec + '|output'],
        cmd = ' && '.join([
            cmd,
            'echo $output > $OUTS',
        ]),
        outs = {
            'formatted_output': [f'out/formatted_output'],
        },
        deps = [build_exec],
        building_description = f'Collecting build script outputs for {name}...',
    )


def _collect_extern_paths(
        crate_name:str,
        edition:str,
        crate_type:str,
        features:list,
        deps:list,
        compile_env:dict=None,
        test:bool=False,
):
    """Returns the pre-build function to apply --extern to the rustc command"""
    def extern_flags(full_dep, labels, rename=None):
        dep = full_dep.split(':')[1]
        externs = []
        for label in labels:
            flag = label.split(':')
            dep_crate = flag[0].replace('-', '_')
            dep_path = flag[1]
            if rename and (rename == dep_crate or dep == dep_crate):
                externs.append(f'--extern {rename}={dep_path}')
            elif not rename and dep == dep_crate:
                externs.append(f'--extern {dep_crate}={dep_path}')
        return externs
            
    def collect_extern_paths(name):
        externs = []
        label_format = 'rust_md_path:'
        if crate_type in ["bin", "proc-macro"]:
            label_format = 'rust_crate_path:'
            if crate_type == 'proc-macro':
                externs.append('--extern proc_macro')    
        if isinstance(deps, dict):
            for rename, dep in deps.items():
                labels = get_labels(dep, label_format)
                externs += extern_flags(dep, labels, rename)
        elif isinstance(deps, list):
            #split_deps = [ ':' + dep.split(':')[1] for dep in deps ]
            for dep in deps:
                labels = get_labels(dep, label_format)
                externs += extern_flags(dep, labels)
        else:
            fail(f'Unknown dep type {deps}')
        if externs:
            cmds, _ = _rustc_cmds(
                crate_name=crate_name if not test else f'{crate_name}_test',
                edition=edition,
                err_format='human',
                crate_type=crate_type,
                externs=externs,
                deps=deps,
                compile_env=compile_env,
                test=test,
            )
            for k, v in cmds.items():
                set_command(name, k, v)
    return collect_extern_paths

