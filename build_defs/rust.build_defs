def _rustc_cmds(
        name:str,
        crate_name:str,
        edition:str="2021",
        err_format:str='human',
        crate_type:str='lib',
        emit:str|list=['dep-info', 'link'],
        codegen:dict={
            'embed-bitcode': 'no',
            'incremental': 'third_party/rust/target/debug/incremental',
        },
        features:list=None,
        out_dir='target/debug/deps',
        search_path:str|list|dict=None,
        externs:list=None,
        test:bool=False,
):
    """Returns the commands to pass to rustc, and tools to use for it.
We replicate the way Cargo invokes the rustc compiler as close as possible.

    Args:
        name (str): Name of the rule. Required.
        crate_name (str): Name of the crate being built. Required.
        edition (str): Edition of rust to use for this crate specified in the crate's Cargo.toml.
                  Rust has different editions (2015, 2018, 2021) that represent sets of language 
                  features. Ensures crate is compiled with appropriate features.
        err_format (str): Controles the format of error messages. Messages are printed to stderr. The
                  valid options are: human, json, short.
        crate_type (str|list): Instructs rustc on which crate types to build. The valid crate types
                  are: lib (defaults to rlib), rlib, staticlib, dylib, cdylib, bin, proc-macro.
        emit (str|list): Controls the type of output files generated by the compiler. The valid emit
                  kinds are: asm, dep-info, link, llvm-bc, llvm-ir, metadaat, mir, obj.
        codegen (dict): All of these options are passed to rustc via -C flags, short for codegen. To
                  see a version of this list for your compiler run `plz rustc -- -C help`.
        features (list): Configures the compilation environment. These flags turn on or off various
                  `#[cfg]` settings for conditional compilation. For example, `--cfg feature="serde"`
                   turns on `#[cfg(feature = "serde")]`.
        out_dir (str): The outputted crate will be written to this directory.
        search_path (str|list|dict): Options are passed to rust via -L flags. Adds path to search 
                  for crates and libraries. If a dict, it specifies the search_path in the form 
                  `-L KIND=PATH` where KIND may be one of: dependency, crate, native, framework, all.
        externs (list): Specifies where external libraries are located. Allows you to pass the name
                  and location for an external crate of a direct dependency. The given crate name is
                  added to the extern prelude, similar to specifying `extern crate` within the root
                  module.
    """
    cmd = [ '$TOOLS_RUSTC', '$SRCS' ]
    if crate_name:
        cmd.append('--crate-name=' + crate_name)
    if edition:
        cmd.append(f'--edition={edition}')
    if err_format:
        cmd.append(f'--error-format={err_format}')
        if err_format == 'json':
            cmd.append('--json=diagnostic-rendered-ansi,artifacts,future-incompat')
    cmd.append('--diagnostic-width=150')
    if crate_type is None:
        pass
    elif isinstance(crate_type, str):
        cmd.append(f'--crate-type {crate_type}')
    elif isinstance(crate_type, list):
        crate_types = ','.join(crate_type)
        cmd.append(f'--crate-type {crate_types}')
    if emit is None:
        pass
    elif isinstance(emit, str):
        cmd.append(f'--emit={emit}')
    elif isinstance(emit, list):
        emits = ','.join(emit)
        cmd.append(f'--emit={emits}')
    if codegen:
        # TODO: -C metadata=xxx-hash-xxx
        # TODO: -C extra-filename=-xxx-hash-xxx 
        cmd.extend([f'-C {k}={v}' for k,v in sorted(codegen.items())])
    if features:
        cmd.extend([f'--cfg feature=\\"{feature}\\"' for feature in features])
    # if out_dir:
    #     # TODO: use name-metadata instead of just name.
    #     cmd.append(f'--out-dir {out_dir}')
    if search_path is None:
        pass
    elif isinstance(search_path, str):
        cmd.append(f'-L {search_path}')
    elif isinstance(search_path, list):
        cmd.extend([f'-L {path}' for path in search_path])
    elif isinstance(search_path, dict):
        cmd.extend([f'-L {k}={v}' for k,v in sorted(search_path.items())])
    cmd.append(f'-L $(cat $TOOLS_TARGET)/plz-out/gen/third_party/rust/{out_dir}')
    if externs:
        cmd.extend([extern for extern in externs])
    if CONFIG.RUST_STDLIB or CONFIG.RUST_TOOLCHAIN:
        cmd.append('-L $TOOLS_STDLIB')
    if test:
        cmd.append('--test')
    cmd = ' '.join(cmd)
    return {
        'dbg': cmd + ' -g',
        'opt': cmd + ' -O',
    }, {
        'rustc': [(CONFIG.RUST_TOOLCHAIN + '_rustc') if CONFIG.RUST_TOOLCHAIN else CONFIG.RUSTC_TOOL],
        'stdlib': [(CONFIG.RUST_TOOLCHAIN + '_stdlib') if CONFIG.RUST_TOOLCHAIN else CONFIG.RUST_STDLIB],
        'target': [(CONFIG.RUST_TOOLCHAIN + '_target') if CONFIG.RUST_TOOLCHAIN else CONFIG.RUST_TARGET_DIR],
    }


def rust_library(
        name:str, root:str, modules:list=None, deps:list=[], visibility=None, edition:str="2018",
):
    """Defines a build rule for a Rust library.

    Args:
      name: Name of the crate we're creating.
      root: The crate root is a source file that the Rust compiler starts from and makes up the root module of the crate.
      modules: The modules that make up the crate.
      deps: Dependencies of this rule needed for it to compile.
      visibility: Visibility declaration.
    """
    if modules:
        filegroup(
            name=f'{name}_mods',
            srcs=modules,
        )
        deps.append(f':{name}_mods')
    
    cmd, tools = _rustc_cmds(
        name=name,
        crate_name=name,
        edition=edition,
    )
    build_rule(
        name = name,
        srcs = [root],
        outs = [f'lib{name}.rlib'],
        cmd = cmd,
        deps = deps,
        visibility = visibility,
        requires = ['rust'],
        tools = tools,
        pre_build=_collect_extern_paths(
            name=name,
            edition=edition,
            crate_type='lib',
            deps=deps,
        ) if deps else None,
    )


def rust_binary(name, main, deps=None, visibility=None, edition='2018'):
    """Defines a build rule for a Rust standalone binary.

    Args:
      name: Name of the rule.
      main: Source files containing the main() function.
      deps: Dependencies of this rule needed for it to compile.
      visibility: Visibility declaration.
    """
    cmd, tools = _rustc_cmds(
        name=name,
        crate_name=name,
        edition=edition,
        crate_type='bin',
    )
    build_rule(
        name = name,
        srcs = [main],
        binary = True,
        outs = [name],
        cmd = cmd,
        deps = deps,
        visibility = visibility,
        requires = ['rust'],
        tools = tools,
        pre_build=_collect_extern_paths(
            name=name,
            edition=edition,
            crate_type='bin',
            deps=deps,
        ) if deps else None,
    )


def rust_test(name, srcs, deps=None, visibility=None):
    """Defines a test rule for a Rust library.

    Note that while this correctly runs tests, the Rust test runner has no
    ability to output in any format we're familiar with. This is a known issue
    (see https://github.com/rust-lang/rfcs/issues/816) but it isn't resolved
    yet, so for now we do a straight pass-fail. Rumour has it that plz may gain
    some ability to parse Rust test logs soonish in which case we'd get slightly
    more detailed feedback here.

    Args:
      name: Name of the rule.
      srcs: Source files for test.
      deps: Dependencies of this rule needed for it to compile.
      visibility: Visibility declaration.
    """
    cmd, tools = _rustc_cmds(deps, test=True)
    build_rule(
        name = name,
        srcs = srcs,
        binary = True,
        test = True,
        outs = [name],
        cmd = cmd,
        deps = deps,
        visibility = visibility,
        requires = ['rust'],
        no_test_output = True,  # see above
        tools = tools,
    )


def _collect_extern_paths(
        name:str, edition:str, crate_type:str, deps:list,
):
    """Returns the pre-build function to apply --extern to the rustc command"""
    def extern_flags(labels):
        externs = []
        for label in labels: # TODO: filter out only the ones we need.
            flag = label.split(':')
            log.warning(f'flag: {flag}')
            crate = flag[0].replace('-', '_')
            path = flag[1]
            externs.append(f'--extern {crate}={path}')
        return externs
            
    def collect_extern_paths(name):
        externs = []
        for dep in deps:
            log.debug(f"Getting labels for {dep}")
            labels = get_labels(dep, 'rust_crate_path:')
            log.debug(f"Found {labels} labels for {dep}")
            flags = extern_flags(labels)
            externs += flags
        if externs:
            cmds, _ = _rustc_cmds(
                name=name,
                crate_name=name,
                edition=edition,
                err_format='human',
                crate_type=crate_type,
                #out_dir=out_dir,
                externs=externs,
            )
            for k, v in cmds.items():
                log.warning(k, v)
                set_command(name, k, v)
    return collect_extern_paths


CONFIG.setdefault('RUSTC_TOOL', 'rustc')
CONFIG.setdefault('RUST_STDLIB', None)
CONFIG.setdefault('RUST_TOOLCHAIN', None)
CONFIG.setdefault('RUST_TARGET_DIR', None)
